//
// GCC_PERF
//
// A command line tool to test the performance of 32 and 64-bit ARM platforms
// The purpose of this program is to highlight the performance differences across
// different SoC's and the difference between 32 and 64-bit ARM code generated by GCC.
// A set of 9 simple math functions are written in C, SIMD intrinsics and assembly
// language. The compiler is asked to do its best to auto-vectorize and optimize
// the functions.
// Each test is first validated by comparing the output of the C code to the SIMD
// and ASM versions. Once validated, the function is given a large buffer test
// (larger than the L2 cache) and then a small buffer test (fits in L1 cache).
// The 32-bit SIMD and ASM code use prefetch hints to help the "large" test perform
// better. This has the side affect of slightly hurting the performance of the "small"
// tests.
//
// Written by Larry Bank
//
// Project started 3/16/2016
//

#include <math.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>
#include <string.h>
#include <arm_neon.h>

typedef int (*PFNTEST)(void *src, void *dest, int iLen);

typedef struct tagCOMPLEX
{
float r;
float i;
} COMPLEX;

typedef struct tagTests
{
char *szTestName;
PFNTEST pCFunc;
PFNTEST pSIMDFunc;
PFNTEST pASMFunc;
bool bFloat;
} TESTS;

enum {
	MODE_VALIDATE=0,
	MODE_C_PERF,
	MODE_SIMD_PERF,
	MODE_ASM_PERF
};

// Forward declarations
int MilliTime();
void RunTest(int iTest, int iMode, int iIterations, float *pFloatArray1, float *pFloatArray2, int32_t *pIntArray1, int32_t *pIntArray2, void *pDest, void *pCompare, bool *bPassed, int iLen);

int c_integer_sum(void *in, void *out, int iLen);
int simd_integer_sum(void *in, void *out, int iLen);
extern int asm_integer_sum(void *in, void *out, int iLen);
int c_float_sum(void *in, void *out, int iLen);
int simd_float_sum(void *in, void *out, int iLen);
extern int asm_float_sum(void *in, void *out, int iLen);
int c_integer_diff(void *in, void *out, int iLen);
int simd_integer_diff(void *in, void *out, int iLen);
extern int asm_integer_diff(void *in, void *out, int iLen);
int c_float_diff(void *in, void *out, int iLen);
int simd_float_diff(void *in, void *out, int iLen);
extern int asm_float_diff(void *in, void *out, int iLen);
int c_float_max(void *in, void *out, int iLen);
int simd_float_max(void *in, void *out, int iLen);
extern int asm_float_max(void *in, void *out, int iLen);
int c_integer_max(void *in, void *out, int iLen);
int simd_integer_max(void *in, void *out, int iLen);
extern int asm_integer_max(void *in, void *out, int iLen);
int c_float_accumulate(void *in, void *out, int iLen);
int simd_float_accumulate(void *in, void *out, int iLen);
extern int asm_float_accumulate(void *in, void *out, int iLen);
int c_integer_accumulate(void *in, void *out, int iLen);
int simd_integer_accumulate(void *in, void *out, int iLen);
extern int asm_integer_accumulate(void *in, void *out, int iLen);

int c_multiply_complex(void *in, void *out, int iLen);
int simd_multiply_complex(void *in, void *out, int iLen);
extern int asm_multiply_complex(void *in, void *out, int iLen);

#define TEST_COUNT 9
// List of functions to test
TESTS testList[TEST_COUNT] = {
{"Multiply Complex",c_multiply_complex, simd_multiply_complex, asm_multiply_complex, true},
{"Integer Sum",c_integer_sum, simd_integer_sum, asm_integer_sum, false},
{"Float Sum",c_float_sum, simd_float_sum, asm_float_sum, true},
{"Integer Difference",c_integer_diff, simd_integer_diff, asm_integer_diff, false},
{"Float Difference",c_float_diff, simd_float_diff, asm_float_diff, true},
{"Integer Max",c_integer_max, simd_integer_max, asm_integer_max, false},
{"Float Max", c_float_max, simd_float_max, asm_float_max, true},
{"Integer Accumulate",c_integer_accumulate, simd_integer_accumulate, asm_integer_accumulate, false},
{"Float Accumulate", c_float_accumulate, simd_float_accumulate, asm_float_accumulate, true}
};

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : main(int, char**)                                          *
 *                                                                          *
 ****************************************************************************/
int main( int argc, char *argv[ ])
{
int i, iTest, iTime, iLen, iIterations;
int iStart, iEnd;
int iColor;
void *pFloatMem1, *pFloatMem2, *pIntMem1, *pIntMem2, *pDest, *pCompare;
float *pf1, *pf2;
int32_t *pi1, *pi2;
char *szLabel;
char szColor[32];
char *szUnColor;
bool bPassed;
bool bUseColor;

	printf("GCC_PERF tests 1.0\n");
	printf("Written by Larry Bank\n");

	if (argc == 2) // run a single test
	{
		sscanf(argv[1], "%d", &iStart);
		iEnd = iStart;
		if (iStart < 0 || iStart >= TEST_COUNT)
		{
			// print error message and list the test names and numbers
			printf("Requested test is out of range\n");
			for (iTest=0; iTest<TEST_COUNT; iTest++)
			{
				printf("%d: %s\n", iTest, testList[iTest].szTestName);
			}
			return 0;
		}
	}
	else
	{
		iStart = 0;
		iEnd = TEST_COUNT - 1;
	}

	if (iStart == iEnd)
		printf("running ARM NEON test %d, %d-bit word size\n", iStart, (int)sizeof(void *)*8);
	else
		printf("running ARM NEON tests %d-%d, %d-bit word size\n", iStart, iEnd, (int)sizeof(void *)*8);

	if (argc >= 3)
	{	// no color
		bUseColor = false;
		strcpy(szColor,"");
		szUnColor = "";
	}
	else
	{
		bUseColor = true;
		szUnColor = "\033[0m";
		iColor = 32;
	}

	iIterations = 200;
	iLen = 0x100000; // 4MB (1MB x sizeof(float)) should be enough to not fit in L2 cache    
	pFloatMem1 = (void *)malloc(iLen * sizeof(float));
	pFloatMem2 = (void *)malloc(iLen * sizeof(float));
	pIntMem1 = (void *)malloc(iLen * sizeof(int32_t));
	pIntMem2 = (void *)malloc(iLen * sizeof(int32_t));
	pDest = (void *)malloc(iLen * sizeof(float));
	pCompare = (void *)malloc(iLen * sizeof(float));

	// Prepare some reasonable test data
	pf1 = (float *)pFloatMem1;
	pi1 = (int32_t *)pIntMem1;
	pf2 = (float *)pFloatMem2;
	pi2 = (int32_t *)pIntMem2;
	for (i=0; i<iLen; i++)
	{
		pi1[i] = (rand() & 0xfff)-2048;
		pf1[i] = (float)pi1[i];
		pi2[i] = (rand() & 0xfff)-2048;
		pf2[i] = (float)pi2[i];
	}
	for (iTest=iStart; iTest <= iEnd; iTest++)
	{
		szLabel = testList[iTest].szTestName;
		RunTest(iTest, MODE_VALIDATE, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
		if (!bPassed)
		{
			printf("\033[1;31m%s\033[0m failed\n", szLabel);
			continue;
		}
		if (bUseColor)
		{
			sprintf(szColor, "\033[1;%dm", iColor);
		}
		iTime = MilliTime();
		RunTest(iTest, MODE_C_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
		iTime = MilliTime() - iTime;
		printf("%s%s%s C (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iTime = MilliTime();
		RunTest(iTest, MODE_SIMD_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
		iTime = MilliTime() - iTime;
		printf("%s%s%s SIMD (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iTime = MilliTime();
		RunTest(iTest, MODE_ASM_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
		iTime = MilliTime() - iTime;
		printf("%s%s%s ASM (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iTime = MilliTime();
		RunTest(iTest, MODE_C_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
		iTime = MilliTime() - iTime;
		printf("%s%s%s C (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iTime = MilliTime();
		RunTest(iTest, MODE_SIMD_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
		iTime = MilliTime() - iTime;
		printf("%s%s%s SIMD (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iTime = MilliTime();
		RunTest(iTest, MODE_ASM_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
		iTime = MilliTime() - iTime;
		printf("%s%s%s ASM (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		iColor++;
		if (iColor > 33) iColor = 32; // toggle between green and yellow for passing tests
	}

	free(pFloatMem1);
	free(pFloatMem2);
	free(pIntMem1);
	free(pIntMem2);
	free(pDest);
	free(pCompare);
	return 0;

} /* main() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MilliTime()                                                *
 *               returns the relative time in milliseconds                  *
 *                                                                          *
 ****************************************************************************/
int MilliTime()
{
int iTime;
struct timespec res;

    clock_gettime(CLOCK_MONOTONIC, &res);
    iTime = 1000*res.tv_sec + res.tv_nsec/1000000;

    return iTime;
} /* MilliTime() */

/**************************************************************************************
 *                                                                                    *
 *  FUNCTION   : RunTest(int, int, int, float *, float *, int32_t *, int32_t *,       *
 *                       void *, bool **, int)                                        *
 *               Runs the given test N times.                                         *
 *                                                                                    *
 **************************************************************************************/
void RunTest(int iTest, int iMode, int iIterations, float *pFloatArray1, float *pFloatArray2, int32_t *pIntArray1, int32_t *pIntArray2, void *pDest, void *pCompare, bool *bPassed, int iLen)
{
int i = 0;
int iSize;
bool bSIMD, bASM;
void *pSrc1, *pSrc2;

	pSrc1 = (testList[iTest].bFloat) ? (void *)pFloatArray1 : (void *)pIntArray1;
	pSrc2 = (testList[iTest].bFloat) ? (void *)pFloatArray2 : (void *)pIntArray2;

	if (iMode == MODE_VALIDATE)
	{
		*bPassed = bSIMD = bASM = false;

		memcpy(pDest, pSrc2, iLen * sizeof(int32_t));
		iSize = (*testList[iTest].pCFunc)(pSrc1, pDest, iLen);
		memcpy(pCompare, pSrc2, iLen * sizeof(int32_t));
		(*testList[iTest].pSIMDFunc)(pSrc1, pCompare, iLen);
		if (memcmp(pDest, pCompare, iSize*sizeof(int32_t)) == 0)
		{
			bSIMD = true;
		}
		else
		{
			printf("SIMD failed to compare\n");
		}
		memcpy(pCompare, pSrc2, iLen * sizeof(int32_t));
		(*testList[iTest].pASMFunc)(pSrc1, pCompare, iLen);
		if (memcmp(pDest, pCompare, iSize*sizeof(int32_t)) == 0)
		{
			bASM = true;
		}
		else
		{
			printf("ASM failed to compare\n");
		}
		if (bASM && bSIMD)
		{
			*bPassed = true;
		}
	}
	else if (iMode == MODE_C_PERF)
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pCFunc)(pSrc1, pDest, iLen);
		}
	}
	else if (iMode == MODE_SIMD_PERF)
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pSIMDFunc)(pSrc1, pDest, iLen);
		}
	}
	else // must be MODE_ASM_PERF
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pASMFunc)(pSrc1, pDest, iLen);
		}
	}
} /* RunTest() */

// Perf test functions (C and SIMD). ASM is in a separate file

// Multiply 2 complex numbers together and store in the output array
int c_multiply_complex(void *in, void *out, int iLen)
{
int x;
COMPLEX *a = (COMPLEX *)in; // treat pairs of floats as Complex numbers
COMPLEX *b = (COMPLEX *)out;
float r, i;

    for(x=0; x<iLen/2; x++)
        {
        r = a[x].r * b[x].r - a[x].i * b[x].i;
        i = a[x].i * b[x].r + a[x].r * b[x].i;
	b[x].r = r;
	b[x].i = i;
        }
    return iLen;
} /* c_multiply_complex() */

// Multiply 2 complex numbers together and store in the output array
int simd_multiply_complex(void *in, void *out, int iLen)
{
int i;
COMPLEX *a = (COMPLEX *)in; // treat pairs of floats as Complex numbers
COMPLEX *b = (COMPLEX *)out;

    float32x4x2_t f32_a0, f32_a1, f32_b0, f32_b1, f32_c0, f32_c1;

    for (i=0; i< (iLen/2)-7; i+= 8)
    {
        f32_a0 = vld2q_f32((float *)&a[i]); // separate the real/imaginary values while reading
        f32_b0 = vld2q_f32((float *)&b[i]);
        f32_a1 = vld2q_f32((float *)&a[i+4]);
        f32_b1 = vld2q_f32((float *)&b[i+4]);
        __builtin_prefetch(&a[i+64]);
        __builtin_prefetch(&b[i+64]);
        f32_c0.val[0] = vmulq_f32(f32_a0.val[0], f32_b0.val[0]); // c0.r = a(real) * b(real)
        f32_c0.val[1] = vmulq_f32(f32_a0.val[1], f32_b0.val[0]); // c0.i = a(imag) * b(real)
        f32_c0.val[0] = vmlsq_f32(f32_c0.val[0], f32_a0.val[1], f32_b0.val[1]); // c0.r -= a(imag) * b(imag)
        f32_c0.val[1] = vmlaq_f32(f32_c0.val[1], f32_a0.val[0], f32_b0.val[1]); // c0.i += a(real) * b(imag)
        f32_c1.val[0] = vmulq_f32(f32_a1.val[0], f32_b1.val[0]); // c1.r = a(real) * b(real)
        f32_c1.val[1] = vmulq_f32(f32_a1.val[1], f32_b1.val[0]); // c1.i = a(imag) * b(real)
        f32_c1.val[0] = vmlsq_f32(f32_c1.val[0], f32_a1.val[1], f32_b1.val[1]); // c1.r -= a(imag) * b(imag)
        f32_c1.val[1] = vmlaq_f32(f32_c1.val[1], f32_a1.val[0], f32_b1.val[1]); // c1.i += a(real) * b(imag)
        vst2q_f32((float *)&b[i], f32_c0);
        vst2q_f32((float *)&b[i+4], f32_c1);
    }
    return iLen;
} /* simd_multiply_complex() */

// Add the values from 2 arrays and store in the destination array
int c_integer_sum(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* c_integer_sum() */

// Add the values from 2 arrays and store in the destination array
int simd_integer_sum(void *in, void *out, int iLen)
{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	int32x4_t i32_b0, i32_b1, i32_b2, i32_b3;
	int i;
        int32_t *s = (int32_t *)in;
	int32_t *d = (int32_t *)out;

	i = 0;
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_s32(&d[i]);
		i32_b1 = vld1q_s32(&d[i+4]);
		i32_b2 = vld1q_s32(&d[i+8]);
		i32_b3 = vld1q_s32(&d[i+12]);
        	__builtin_prefetch(&d[i+96]);
		i32_a0 = vaddq_s32(i32_a0, i32_b0);
		i32_a1 = vaddq_s32(i32_a1, i32_b1);
		i32_a2 = vaddq_s32(i32_a2, i32_b2);
		i32_a3 = vaddq_s32(i32_a3, i32_b3);
		vst1q_s32(&d[i], i32_a0);
		vst1q_s32(&d[i+4], i32_a1);
		vst1q_s32(&d[i+8], i32_a2);
		vst1q_s32(&d[i+12], i32_a3);
	}
	for (; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* simd_integer_sum() */

// Add the values from 2 arrays and store in the destination array
int c_float_sum(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* c_float_sum() */

// Add the values from 2 arrays and store in the destination array
int simd_float_sum(void *in, void *out, int iLen)
{
	float32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	float32x4_t i32_b0, i32_b1, i32_b2, i32_b3;
	int i;
        float *s = (float *)in;
	float *d = (float *)out;

	i = 0;
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_f32(&s[i]);
		i32_a1 = vld1q_f32(&s[i+4]);
		i32_a2 = vld1q_f32(&s[i+8]);
		i32_a3 = vld1q_f32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_f32(&d[i]);
		i32_b1 = vld1q_f32(&d[i+4]);
		i32_b2 = vld1q_f32(&d[i+8]);
		i32_b3 = vld1q_f32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vaddq_f32(i32_a0, i32_b0);
		i32_a1 = vaddq_f32(i32_a1, i32_b1);
		i32_a2 = vaddq_f32(i32_a2, i32_b2);
		i32_a3 = vaddq_f32(i32_a3, i32_b3);
		vst1q_f32(&d[i], i32_a0);
		vst1q_f32(&d[i+4], i32_a1);
		vst1q_f32(&d[i+8], i32_a2);
		vst1q_f32(&d[i+12], i32_a3);
	}
	for (; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* simd_float_sum() */

// Subtract the values from 2 arrays and store in the destination array
int c_integer_diff(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* c_integer_diff() */

// Subtract the values from 2 arrays and store in the destination array
int simd_integer_diff(void *in, void *out, int iLen)
{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	int32x4_t i32_b0, i32_b1, i32_b2, i32_b3;
	int i;
        int32_t *s = (int32_t *)in;
	int32_t *d = (int32_t *)out;

	i = 0;
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_s32(&d[i]);
		i32_b1 = vld1q_s32(&d[i+4]);
		i32_b2 = vld1q_s32(&d[i+8]);
		i32_b3 = vld1q_s32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vsubq_s32(i32_a0, i32_b0);
		i32_a1 = vsubq_s32(i32_a1, i32_b1);
		i32_a2 = vsubq_s32(i32_a2, i32_b2);
		i32_a3 = vsubq_s32(i32_a3, i32_b3);
		vst1q_s32(&d[i], i32_a0);
		vst1q_s32(&d[i+4], i32_a1);
		vst1q_s32(&d[i+8], i32_a2);
		vst1q_s32(&d[i+12], i32_a3);
	}
	for (; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* simd_integer_diff() */

// Subtract the values from 2 arrays and store in the destination array
int c_float_diff(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* c_float_diff() */

// Subtract the values from 2 arrays and store in the destination array
int simd_float_diff(void *in, void *out, int iLen)
{
	float32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	float32x4_t i32_b0, i32_b1, i32_b2, i32_b3;
	int i;
        float *s = (float *)in;
	float *d = (float *)out;

	i = 0;
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_f32(&s[i]);
		i32_a1 = vld1q_f32(&s[i+4]);
		i32_a2 = vld1q_f32(&s[i+8]);
		i32_a3 = vld1q_f32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_f32(&d[i]);
		i32_b1 = vld1q_f32(&d[i+4]);
		i32_b2 = vld1q_f32(&d[i+8]);
		i32_b3 = vld1q_f32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vsubq_f32(i32_a0, i32_b0);
		i32_a1 = vsubq_f32(i32_a1, i32_b1);
		i32_a2 = vsubq_f32(i32_a2, i32_b2);
		i32_a3 = vsubq_f32(i32_a3, i32_b3);
		vst1q_f32(&d[i], i32_a0);
		vst1q_f32(&d[i+4], i32_a1);
		vst1q_f32(&d[i+8], i32_a2);
		vst1q_f32(&d[i+12], i32_a3);
	}
	for (; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* simd_float_diff() */

// Find the maximum value in an array
int c_float_max(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;
float max;

	max = -10000;
	for (i=0; i<iLen; i++)
	{
		if (s[i] > max) max = s[i];
	}
	d[0] = max; // store the max value as element 0 in the output
	return 1;
} /* c_float_max() */

// Find the maximum value in an array
int simd_float_max(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	float32x4_t xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	float32x4_t xmmMax0, xmmMax1, xmmMax2, xmmMax3;

        xmmMax0 = vld1q_f32(&s[0]);
        xmmMax1 = vld1q_f32(&s[4]);
        xmmMax2 = vld1q_f32(&s[8]);
        xmmMax3 = vld1q_f32(&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = vld1q_f32(&s[i]);
            xmmCur1 = vld1q_f32(&s[i+4]);
            xmmCur2 = vld1q_f32(&s[i+8]);
            xmmCur3 = vld1q_f32(&s[i+12]);
	    __builtin_prefetch(&s[i+96]);
            xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = vmaxq_f32(xmmCur1, xmmMax1);
	    xmmMax2 = vmaxq_f32(xmmCur2, xmmMax2);
	    xmmMax3 = vmaxq_f32(xmmCur3, xmmMax3);
        }
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax1);
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax2);
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = vextq_f32(xmmMax0, xmmMax0, 2); // compare upper and lower 2 values
        xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = vextq_f32(xmmMax0, xmmMax0, 1); // compare last 2 values
        xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // keep max 1
        d[0] = vgetq_lane_f32(xmmMax0, 0);
        
	return 1;
} /* simd_float_max() */

// Find the maximum value in an array
int c_integer_max(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;
int32_t max;

	max = -10000;
	for (i=0; i<iLen; i++)
	{
		if (s[i] > max) max = s[i];
	}
	d[0] = max; // store the max value as element 0 in the output
	return 1;
} /* c_integer_max() */

// Find the maximum value in an array
int simd_integer_max(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	int32x4_t xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	int32x4_t xmmMax0, xmmMax1, xmmMax2, xmmMax3;

        xmmMax0 = vld1q_s32(&s[0]);
        xmmMax1 = vld1q_s32(&s[4]);
        xmmMax2 = vld1q_s32(&s[8]);
        xmmMax3 = vld1q_s32(&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = vld1q_s32(&s[i]);
            xmmCur1 = vld1q_s32(&s[i+4]);
            xmmCur2 = vld1q_s32(&s[i+8]);
            xmmCur3 = vld1q_s32(&s[i+12]);
            __builtin_prefetch(&s[i+96]);
            xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = vmaxq_s32(xmmCur1, xmmMax1);
	    xmmMax2 = vmaxq_s32(xmmCur2, xmmMax2);
	    xmmMax3 = vmaxq_s32(xmmCur3, xmmMax3);
        }
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax1);
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax2);
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = vextq_s32(xmmMax0, xmmMax0, 2); // compare upper and lower 2 values
        xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = vextq_s32(xmmMax0, xmmMax0, 1); // compare last 2 values
        xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // keep max 1
        d[0] = vgetq_lane_s32(xmmMax0, 0);
	return 1;
} /* simd_integer_max() */

// Calculate the sum of all values in an array
int c_float_accumulate(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;
float sum = 0.0;

	for (i=0; i<iLen; i++)
	{
		sum += s[i];
	}
	d[0] = sum;
	return 1;
} /* c_float_accumulate() */

// Calculate the sum of all values in an array
int simd_float_accumulate(void *in, void *out, int iLen)
{
	float32x4_t f32_a0, f32_a1, f32_a2, f32_a3, f32_sum;
        float32x2_t f32_sum_narrow;
	int i;
	float fSum;
        float *s = (float *)in;
	float *d = (float *)out;

	i = 0;
        fSum = 0.0;
        f32_sum = vdupq_n_f32(0.0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		f32_a0 = vld1q_f32(&s[i]);
		f32_a1 = vld1q_f32(&s[i+4]);
		f32_a2 = vld1q_f32(&s[i+8]);
		f32_a3 = vld1q_f32(&s[i+12]);
		f32_a0 = vaddq_f32(f32_a0, f32_a1);
		f32_a1 = vaddq_f32(f32_a2, f32_a3);
                f32_sum = vaddq_f32(f32_sum, f32_a0);
                f32_sum = vaddq_f32(f32_sum, f32_a1);
	}
        f32_sum_narrow = vadd_f32(vget_high_f32(f32_sum), vget_low_f32(f32_sum));
        f32_sum_narrow = vpadd_f32(f32_sum_narrow, f32_sum_narrow);
        fSum = vget_lane_f32(f32_sum_narrow, 0);
	for (; i<iLen; i++)
	{
		fSum += s[i];
	}
	d[0] = fSum;
	return 1;
} /* simd_float_accumulate() */

// Calculate the sum of all values in an array
int c_integer_accumulate(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;
int sum = 0;

	for (i=0; i<iLen; i++)
	{
		sum += s[i];
	}
	d[0] = sum;
	return 1;
} /* c_integer_accumulate() */

// Calculate the sum of all values in an array
int simd_integer_accumulate(void *in, void *out, int iLen)
{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3, i32_sum;
        int32x2_t i32_sum_narrow;
	int i;
	int32_t iSum;
        int32_t *s = (int32_t *)in;
	int32_t *d = (int32_t *)out;

	i = 0;
        iSum = 0;
        i32_sum = vdupq_n_s32(0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
		i32_a0 = vaddq_s32(i32_a0, i32_a1);
		i32_a1 = vaddq_s32(i32_a2, i32_a3);
                i32_sum = vaddq_s32(i32_sum, i32_a0);
                i32_sum = vaddq_s32(i32_sum, i32_a1);
	}
        i32_sum_narrow = vadd_s32(vget_high_s32(i32_sum), vget_low_s32(i32_sum));
        i32_sum_narrow = vpadd_s32(i32_sum_narrow, i32_sum_narrow);
        iSum = vget_lane_s32(i32_sum_narrow, 0);
	for (; i<iLen; i++)
	{
		iSum += s[i];
	}
	d[0] = iSum;
	return 1;
} /* simd_integer_accumulate() */
