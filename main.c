//
// GCC_PERF
//
// A command line tool to test the performance of 32 and 64-bit ARM platforms
// The purpose of this program is to highlight the performance differences across
// different SoC's and the difference between 32 and 64-bit ARM code generated by GCC.
// A set of 9 simple math functions are written in C, SIMD intrinsics and assembly
// language. The compiler is asked to do its best to auto-vectorize and optimize
// the functions.
// Each test is first validated by comparing the output of the C code to the SIMD
// and ASM versions. Once validated, the function is given a large buffer test
// (larger than the L2 cache) and then a small buffer test (fits in L1 cache).
// The 32-bit SIMD and ASM code use prefetch hints to help the "large" test perform
// better. This has the side affect of slightly hurting the performance of the "small"
// tests.
//
// Written by Larry Bank
//
// Project started 3/16/2016
//

#include <math.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <linux/time.h>
#include <string.h>
#ifdef USE_NEON
#include <arm_neon.h>
#endif
#ifdef USE_SSE
#include <emmintrin.h>
#include <tmmintrin.h>
#include <smmintrin.h>
#endif
typedef int (*PFNTEST)(void *src, void *dest, int iLen);

typedef struct tagCOMPLEX
{
float r;
float i;
} COMPLEX;

typedef struct tagTests
{
char *szTestName;
PFNTEST pCFunc;
PFNTEST pSIMDFunc;
PFNTEST pASMFunc;
bool bFloat;
} TESTS;

enum {
	MODE_VALIDATE=0,
	MODE_C_PERF,
	MODE_SIMD_PERF,
	MODE_ASM_PERF
};

// Forward declarations
int MilliTime();
void RunTest(int iTest, int iMode, int iIterations, float *pFloatArray1, float *pFloatArray2, int32_t *pIntArray1, int32_t *pIntArray2, void *pDest, void *pCompare, bool *bPassed, int iLen);

int c_integer_sum(void *in, void *out, int iLen);
int simd_integer_sum(void *in, void *out, int iLen);
int c_float_sum(void *in, void *out, int iLen);
int simd_float_sum(void *in, void *out, int iLen);
int c_integer_diff(void *in, void *out, int iLen);
int simd_integer_diff(void *in, void *out, int iLen);
int c_float_diff(void *in, void *out, int iLen);
int simd_float_diff(void *in, void *out, int iLen);
int c_float_max(void *in, void *out, int iLen);
int simd_float_max(void *in, void *out, int iLen);
int c_integer_max(void *in, void *out, int iLen);
int simd_integer_max(void *in, void *out, int iLen);
int c_float_accumulate(void *in, void *out, int iLen);
int simd_float_accumulate(void *in, void *out, int iLen);
int c_integer_accumulate(void *in, void *out, int iLen);
int simd_integer_accumulate(void *in, void *out, int iLen);
int c_multiply_complex(void *in, void *out, int iLen);
int simd_multiply_complex(void *in, void *out, int iLen);

// Using intrinsics in x86 land is sufficient. It's hard to
// beat the compiler with hand written asm code for these
// type of functions
#ifdef USE_NEON
extern int asm_integer_sum(void *in, void *out, int iLen);
extern int asm_float_sum(void *in, void *out, int iLen);
extern int asm_integer_diff(void *in, void *out, int iLen);
extern int asm_float_diff(void *in, void *out, int iLen);
extern int asm_float_max(void *in, void *out, int iLen);
extern int asm_integer_max(void *in, void *out, int iLen);
extern int asm_float_accumulate(void *in, void *out, int iLen);
extern int asm_integer_accumulate(void *in, void *out, int iLen);
extern int asm_multiply_complex(void *in, void *out, int iLen);
#else
int asm_integer_sum(void *in, void *out, int iLen) { return 0;};
int asm_float_sum(void *in, void *out, int iLen) { return 0;};
int asm_integer_diff(void *in, void *out, int iLen) { return 0;};
int asm_float_diff(void *in, void *out, int iLen) { return 0;};
int asm_integer_max(void *in, void *out, int iLen) { return 0;};
int asm_float_max(void *in, void *out, int iLen) { return 0;};
int asm_integer_accumulate(void *in, void *out, int iLen) { return 0;};
int asm_float_accumulate(void *in, void *out, int iLen) { return 0;};
int asm_multiply_complex(void *in, void *out, int iLen) { return 0;};
#endif // USE_NEON
int c_writebuf_byte(void *in, void *out, int iLen);
int c_writebuf_byte_coalesced(void *in, void *out, int iLen);
int c_writebuf_short(void *in, void *out, int iLen);
int c_writebuf_word(void *in, void *out, int iLen);
int c_writebuf_long(void *in, void *out, int iLen);

#define TEST_COUNT 14
// List of functions to test
TESTS testList[TEST_COUNT] = {
{"Write buffer - byte", c_writebuf_byte, NULL, NULL, false},
{"Write buffer - byte - coalesced", c_writebuf_byte_coalesced, NULL, NULL, false},
{"Write buffer - short (16-bits)", c_writebuf_short, NULL, NULL, false},
{"Write buffer - word (32-bits)", c_writebuf_word, NULL, NULL, false},
{"Write buffer - long (64-bits)", c_writebuf_long, NULL, NULL, false},
{"Multiply Complex",c_multiply_complex, simd_multiply_complex, asm_multiply_complex, true},
{"Integer Sum",c_integer_sum, simd_integer_sum, asm_integer_sum, false},
{"Float Sum",c_float_sum, simd_float_sum, asm_float_sum, true},
{"Integer Difference",c_integer_diff, simd_integer_diff, asm_integer_diff, false},
{"Float Difference",c_float_diff, simd_float_diff, asm_float_diff, true},
{"Integer Max",c_integer_max, simd_integer_max, asm_integer_max, false},
{"Float Max", c_float_max, simd_float_max, asm_float_max, true},
{"Integer Accumulate",c_integer_accumulate, simd_integer_accumulate, asm_integer_accumulate, false},
{"Float Accumulate", c_float_accumulate, simd_float_accumulate, asm_float_accumulate, true}
};

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : main(int, char**)                                          *
 *                                                                          *
 ****************************************************************************/
int main( int argc, char *argv[ ])
{
int i, iTest, iTime, iLen, iIterations;
int iStart, iEnd;
int iColor;
void *pFloatMem1, *pFloatMem2, *pIntMem1, *pIntMem2, *pDest, *pCompare;
float *pf1, *pf2;
int32_t *pi1, *pi2;
char *szLabel;
char szColor[32];
char *szUnColor;
bool bPassed;
bool bUseColor;
char *szCPU;

	printf("GCC_PERF tests 1.0\n");
	printf("Written by Larry Bank\n");

	if (argc == 2) // run a single test
	{
		sscanf(argv[1], "%d", &iStart);
		iEnd = iStart;
		if (iStart < 0 || iStart >= TEST_COUNT)
		{
			// print error message and list the test names and numbers
			printf("Requested test is out of range\n");
			for (iTest=0; iTest<TEST_COUNT; iTest++)
			{
				printf("%d: %s\n", iTest, testList[iTest].szTestName);
			}
			return 0;
		}
	}
	else
	{
		iStart = 0;
		iEnd = TEST_COUNT - 1;
	}

#ifdef USE_NEON
	szCPU = "ARM NEON";
#else
	szCPU = "Intel SSE";
#endif
	if (iStart == iEnd)
		printf("running %s test %d, %d-bit word size\n", szCPU, iStart, (int)sizeof(void *)*8);
	else
		printf("running %s tests %d-%d, %d-bit word size\n", szCPU, iStart, iEnd, (int)sizeof(void *)*8);

	if (argc >= 3)
	{	// no color
		bUseColor = false;
		strcpy(szColor,"");
		szUnColor = "";
	}
	else
	{
		bUseColor = true;
		szUnColor = "\033[0m";
		iColor = 32;
	}

	iIterations = 200;
	iLen = 0x100000; // 4MB (1MB x sizeof(float)) should be enough to not fit in L2 cache    
	pFloatMem1 = (void *)malloc(iLen * sizeof(float));
	pFloatMem2 = (void *)malloc(iLen * sizeof(float));
	pIntMem1 = (void *)malloc(iLen * sizeof(int32_t));
	pIntMem2 = (void *)malloc(iLen * sizeof(int32_t));
	pDest = (void *)malloc(iLen * sizeof(float));
	pCompare = (void *)malloc(iLen * sizeof(float));

	// Prepare some reasonable test data
	pf1 = (float *)pFloatMem1;
	pi1 = (int32_t *)pIntMem1;
	pf2 = (float *)pFloatMem2;
	pi2 = (int32_t *)pIntMem2;
	for (i=0; i<iLen; i++)
	{
		pi1[i] = (rand() & 0xfff)-2048;
		pf1[i] = (float)pi1[i];
		pi2[i] = (rand() & 0xfff)-2048;
		pf2[i] = (float)pi2[i];
	}
	for (iTest=iStart; iTest <= iEnd; iTest++)
	{
		szLabel = testList[iTest].szTestName;
		if (testList[iTest].pSIMDFunc && testList[iTest].pASMFunc)
		{
			RunTest(iTest, MODE_VALIDATE, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
			if (!bPassed)
			{
				printf("\033[1;31m%s\033[0m failed\n", szLabel);
				continue;
			}
		}
		if (bUseColor)
		{
			sprintf(szColor, "\033[1;%dm", iColor);
		}
		if (testList[iTest].pCFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_C_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
			iTime = MilliTime() - iTime;
			printf("%s%s%s C (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
		if (testList[iTest].pSIMDFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_SIMD_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
			iTime = MilliTime() - iTime;
			printf("%s%s%s SIMD (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
#ifdef USE_NEON
		if (testList[iTest].pASMFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_ASM_PERF, iIterations, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen);
			iTime = MilliTime() - iTime;
			printf("%s%s%s ASM (bigger than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
#endif
		if (testList[iTest].pCFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_C_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
			iTime = MilliTime() - iTime;
			printf("%s%s%s C (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
		if (testList[iTest].pSIMDFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_SIMD_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
			iTime = MilliTime() - iTime;
			printf("%s%s%s SIMD (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
#ifdef USE_NEON
		if (testList[iTest].pASMFunc)
		{
			iTime = MilliTime();
			RunTest(iTest, MODE_ASM_PERF, iIterations*0x1000, pFloatMem1, pFloatMem2, pIntMem1, pIntMem2, pDest, pCompare, &bPassed, iLen/0x1000);
			iTime = MilliTime() - iTime;
			printf("%s%s%s ASM (smaller than cache) = %dms\n", szColor, szLabel, szUnColor, iTime);
		}
#endif
		iColor++;
		if (iColor > 33) iColor = 32; // toggle between green and yellow for passing tests
	}

	free(pFloatMem1);
	free(pFloatMem2);
	free(pIntMem1);
	free(pIntMem2);
	free(pDest);
	free(pCompare);
	return 0;

} /* main() */

/****************************************************************************
 *                                                                          *
 *  FUNCTION   : MilliTime()                                                *
 *               returns the relative time in milliseconds                  *
 *                                                                          *
 ****************************************************************************/
int MilliTime()
{
int iTime;
struct timespec res;

    clock_gettime(CLOCK_MONOTONIC, &res);
    iTime = 1000*res.tv_sec + res.tv_nsec/1000000;

    return iTime;
} /* MilliTime() */

/**************************************************************************************
 *                                                                                    *
 *  FUNCTION   : RunTest(int, int, int, float *, float *, int32_t *, int32_t *,       *
 *                       void *, bool **, int)                                        *
 *               Runs the given test N times.                                         *
 *                                                                                    *
 **************************************************************************************/
void RunTest(int iTest, int iMode, int iIterations, float *pFloatArray1, float *pFloatArray2, int32_t *pIntArray1, int32_t *pIntArray2, void *pDest, void *pCompare, bool *bPassed, int iLen)
{
int i = 0;
int iSize;
bool bSIMD, bASM;
void *pSrc1, *pSrc2;

	pSrc1 = (testList[iTest].bFloat) ? (void *)pFloatArray1 : (void *)pIntArray1;
	pSrc2 = (testList[iTest].bFloat) ? (void *)pFloatArray2 : (void *)pIntArray2;

	if (iMode == MODE_VALIDATE)
	{
		*bPassed = bSIMD = bASM = false;

		memcpy(pDest, pSrc2, iLen * sizeof(int32_t));
		iSize = (*testList[iTest].pCFunc)(pSrc1, pDest, iLen);
		memcpy(pCompare, pSrc2, iLen * sizeof(int32_t));
		(*testList[iTest].pSIMDFunc)(pSrc1, pCompare, iLen);
		if (memcmp(pDest, pCompare, iSize*sizeof(int32_t)) == 0)
		{
			bSIMD = true;
		}
		else
		{
			printf("SIMD failed to compare\n");
		}
#ifdef USE_NEON
		memcpy(pCompare, pSrc2, iLen * sizeof(int32_t));
		(*testList[iTest].pASMFunc)(pSrc1, pCompare, iLen);
		if (memcmp(pDest, pCompare, iSize*sizeof(int32_t)) == 0)
		{
			bASM = true;
		}
		else
		{
			printf("ASM failed to compare\n");
		}
#else
		bASM = true;
#endif // USE_NEON
		if (bASM && bSIMD)
		{
			*bPassed = true;
		}
	}
	else if (iMode == MODE_C_PERF)
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pCFunc)(pSrc1, pDest, iLen);
		}
	}
	else if (iMode == MODE_SIMD_PERF)
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pSIMDFunc)(pSrc1, pDest, iLen);
		}
	}
	else // must be MODE_ASM_PERF
	{
		for (i=0; i<iIterations; i++)
		{
			(*testList[iTest].pASMFunc)(pSrc1, pDest, iLen);
		}
	}
} /* RunTest() */

// Perf test functions (C and SIMD). ASM is in a separate file

int c_writebuf_byte(void *in, void *out, int iLen)
{
int i;
uint8_t c, *s, *d;

	s = (uint8_t *)in;
	d = (uint8_t *)out;
	for (i=0; i<iLen*sizeof(int); i++)
	{
// Needed to add some bogus conditional/math ops here to keep the compiler
// from optimizing this into a memcpy
		c = *s++;
		if (i & 1)
			c += 1;
		else
			c -= 1;
		*d++ = c;
	}
	return iLen;
} /* c_writebuf_byte() */

int c_writebuf_byte_coalesced(void *in, void *out, int iLen)
{
int i;
uint8_t c0,c1,c2,c3, *s;
uint32_t u32, *d;

	s = (uint8_t *)in;
	d = (uint32_t *)out;
	for (i=0; i<iLen*sizeof(int); )
	{
// Needed to add some bogus conditional/math ops here to keep the compiler
// from optimizing this into a memcpy
		c0 = *s++;
		if (i & 1)
			c0 += 1;
		else
			c0 -= 1;
		i++;
		c1 = *s++;
		if (i & 1)
			c1 += 1;
		else
			c1 -= 1;
		i++;
		c2 = *s++;
		if (i & 1)
			c2 += 1;
		else
			c2 -= 1;
		i++;
		c3 = *s++;
		if (i & 1)
			c3 += 1;
		else
			c3 -= 1;
		u32 = c0 | (c1 << 8) | (c2 << 16) | (c3 << 24);
		i++;
		*d++ = u32;
	}
	return iLen;
} /* c_writebuf_byte_coalesced() */

int c_writebuf_short(void *in, void *out, int iLen)
{
int i;
uint16_t c, *s, *d;

	s = (uint16_t *)in;
	d = (uint16_t *)out;
	for (i=0; i<iLen*2; i++)
	{
// Needed to add some bogus conditional/math ops here to keep the compiler
// from optimizing this into a memcpy
// with shorts, the compiler can be smart about combining 2 into a word write
// The code below prevents this optimization
		c = *s++;
		if (i & 1)
			c += 0x101;
		else
			c -= 0x101;
		*d++ = c;
	}
	return iLen;
} /* c_writebuf_short() */

int c_writebuf_word(void *in, void *out, int iLen)
{
int i;
uint32_t c, *s, *d;

	s = (uint32_t *)in;
	d = (uint32_t *)out;
	for (i=0; i<iLen; i++)
	{
// keep the compiler from turning this into a memcpy
		c = *s++;
		if (i & 1)
			c += 0x1010101;
		else
			c -= 0x1010101;
		*d++ = c;
	}
	return iLen;
} /* c_writebuf_word() */

int c_writebuf_long(void *in, void *out, int iLen)
{
int i;
uint64_t c, *s, *d;

	s = (uint64_t *)in;
	d = (uint64_t *)out;
	for (i=0; i<iLen/2; i++)
	{
// This will test if your system has a 32-bit or 64-bit memory bus.
// If it's the same speed or slower than the word version, then you have 
// a 32-bit memory bus. If faster, it's 64-bits wide
		c = *s++;
		if (i & 1)
			c += 0x0101010101010101LL;
		else
			c -= 0x0101010101010101LL;
		*d++ = c;
	}
	return iLen;
} /* c_writebuf_long() */

// Multiply 2 complex numbers together and store in the output array
int c_multiply_complex(void *in, void *out, int iLen)
{
int x;
COMPLEX *a = (COMPLEX *)in; // treat pairs of floats as Complex numbers
COMPLEX *b = (COMPLEX *)out;
float r, i;

    for(x=0; x<iLen/2; x++)
        {
        r = a[x].r * b[x].r - a[x].i * b[x].i;
        i = a[x].i * b[x].r + a[x].r * b[x].i;
	b[x].r = r;
	b[x].i = i;
        }
    return iLen;
} /* c_multiply_complex() */

// Multiply 2 complex numbers together and store in the output array
int simd_multiply_complex(void *in, void *out, int iLen)
{
int i;
COMPLEX *a = (COMPLEX *)in; // treat pairs of floats as Complex numbers
COMPLEX *b = (COMPLEX *)out;

    i = 0;

#ifdef USE_NEON
    {
    float32x4x2_t f32_a0, f32_a1, f32_b0, f32_b1, f32_c0, f32_c1;

    for (; i< (iLen/2)-7; i+= 8)
    {
        f32_a0 = vld2q_f32((float *)&a[i]); // separate the real/imaginary values while reading
        f32_b0 = vld2q_f32((float *)&b[i]);
        f32_a1 = vld2q_f32((float *)&a[i+4]);
        f32_b1 = vld2q_f32((float *)&b[i+4]);
        __builtin_prefetch(&a[i+64]);
        __builtin_prefetch(&b[i+64]);
        f32_c0.val[0] = vmulq_f32(f32_a0.val[0], f32_b0.val[0]); // c0.r = a(real) * b(real)
        f32_c0.val[1] = vmulq_f32(f32_a0.val[1], f32_b0.val[0]); // c0.i = a(imag) * b(real)
        f32_c0.val[0] = vmlsq_f32(f32_c0.val[0], f32_a0.val[1], f32_b0.val[1]); // c0.r -= a(imag) * b(imag)
        f32_c0.val[1] = vmlaq_f32(f32_c0.val[1], f32_a0.val[0], f32_b0.val[1]); // c0.i += a(real) * b(imag)
        f32_c1.val[0] = vmulq_f32(f32_a1.val[0], f32_b1.val[0]); // c1.r = a(real) * b(real)
        f32_c1.val[1] = vmulq_f32(f32_a1.val[1], f32_b1.val[0]); // c1.i = a(imag) * b(real)
        f32_c1.val[0] = vmlsq_f32(f32_c1.val[0], f32_a1.val[1], f32_b1.val[1]); // c1.r -= a(imag) * b(imag)
        f32_c1.val[1] = vmlaq_f32(f32_c1.val[1], f32_a1.val[0], f32_b1.val[1]); // c1.i += a(real) * b(imag)
        vst2q_f32((float *)&b[i], f32_c0);
        vst2q_f32((float *)&b[i+4], f32_c1);
    }
    }
#endif // USE_NEON
#ifdef USE_SSE
    {
    __m128 f32_a0, f32_a1, f32_a2, f32_a3;
    __m128 f32_b0, f32_b1, f32_b2, f32_b3;
    __m128 f32_ra0, f32_ra1, f32_rb0, f32_rb1;
    __m128 f32_ia0, f32_ia1, f32_ib0, f32_ib1;

    for (; i< (iLen/2)-7; i+= 8)
    {
	f32_a0 = _mm_loadu_ps((float *)&a[i]);
	f32_b0 = _mm_loadu_ps((float *)&b[i]);
	f32_a1 = _mm_loadu_ps((float *)&a[i+2]);
	f32_b1 = _mm_loadu_ps((float *)&b[i+2]);
	f32_a2 = _mm_loadu_ps((float *)&a[i+4]);
	f32_b2 = _mm_loadu_ps((float *)&b[i+4]);
	f32_a3 = _mm_loadu_ps((float *)&a[i+6]);
	f32_b3 = _mm_loadu_ps((float *)&b[i+6]);
	// separate real and imaginary values
	f32_ra0 = _mm_shuffle_ps(f32_a0, f32_a1, _MM_SHUFFLE(2,0,2,0));
	f32_ia0 = _mm_shuffle_ps(f32_a0, f32_a1, _MM_SHUFFLE(3,1,3,1));
	f32_rb0 = _mm_shuffle_ps(f32_b0, f32_b1, _MM_SHUFFLE(2,0,2,0));
	f32_ib0 = _mm_shuffle_ps(f32_b0, f32_b1, _MM_SHUFFLE(3,1,3,1));
	f32_ra1 = _mm_shuffle_ps(f32_a2, f32_a3, _MM_SHUFFLE(2,0,2,0));
	f32_ia1 = _mm_shuffle_ps(f32_a2, f32_a3, _MM_SHUFFLE(3,1,3,1));
	f32_rb1 = _mm_shuffle_ps(f32_b2, f32_b3, _MM_SHUFFLE(2,0,2,0));
	f32_ib1 = _mm_shuffle_ps(f32_b2, f32_b3, _MM_SHUFFLE(3,1,3,1));
        f32_a0 = _mm_mul_ps(f32_ra0, f32_rb0); // r0 = a(real) * b(real)
        f32_a1 = _mm_mul_ps(f32_ia0, f32_ib0); // r1 = a(imag) * b(imag)
        f32_b0 = _mm_mul_ps(f32_ia0, f32_rb0); // r2 = a(imag) * b(real)
        f32_b1 = _mm_mul_ps(f32_ra0, f32_ib0); // r3 = a(real) * b(imag)
        f32_a2 = _mm_mul_ps(f32_ra1, f32_rb1); // r0 = a(real) * b(real)
        f32_a3 = _mm_mul_ps(f32_ia1, f32_ib1); // r1 = a(imag) * b(imag)
        f32_b2 = _mm_mul_ps(f32_ia1, f32_rb1); // r2 = a(imag) * b(real)
        f32_b3 = _mm_mul_ps(f32_ra1, f32_ib1); // r3 = a(real) * b(imag)
        f32_rb0 = _mm_sub_ps(f32_a0, f32_a1); // b(real) = r0 - r1
        f32_ib0 = _mm_add_ps(f32_b0, f32_b1); // b(imag) = r2 + r3
        f32_rb1 = _mm_sub_ps(f32_a2, f32_a3); // b(real) = r0 - r1
        f32_ib1 = _mm_add_ps(f32_b2, f32_b3); // b(imag) = r2 + r3
	// interleave r/i again
	f32_a0 = (__m128)_mm_unpacklo_epi32((__m128i)f32_rb0, (__m128i)f32_ib0);
	f32_a1 = (__m128)_mm_unpackhi_epi32((__m128i)f32_rb0, (__m128i)f32_ib0);
	f32_a2 = (__m128)_mm_unpacklo_epi32((__m128i)f32_rb1, (__m128i)f32_ib1);
	f32_a3 = (__m128)_mm_unpackhi_epi32((__m128i)f32_rb1, (__m128i)f32_ib1);
        _mm_storeu_ps((float *)&b[i], f32_a0);
        _mm_storeu_ps((float *)&b[i+2], f32_a1);
        _mm_storeu_ps((float *)&b[i+4], f32_a2);
        _mm_storeu_ps((float *)&b[i+6], f32_a3);
    }
    }
#endif // USE_SSE
    return iLen;
} /* simd_multiply_complex() */

// Add the values from 2 arrays and store in the destination array
int c_integer_sum(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* c_integer_sum() */

// Add the values from 2 arrays and store in the destination array
int simd_integer_sum(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	i = 0;

#ifdef USE_NEON
	{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	int32x4_t i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_s32(&d[i]);
		i32_b1 = vld1q_s32(&d[i+4]);
		i32_b2 = vld1q_s32(&d[i+8]);
		i32_b3 = vld1q_s32(&d[i+12]);
        	__builtin_prefetch(&d[i+96]);
		i32_a0 = vaddq_s32(i32_a0, i32_b0);
		i32_a1 = vaddq_s32(i32_a1, i32_b1);
		i32_a2 = vaddq_s32(i32_a2, i32_b2);
		i32_a3 = vaddq_s32(i32_a3, i32_b3);
		vst1q_s32(&d[i], i32_a0);
		vst1q_s32(&d[i+4], i32_a1);
		vst1q_s32(&d[i+8], i32_a2);
		vst1q_s32(&d[i+12], i32_a3);
	}
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128i i32_a0, i32_a1, i32_a2, i32_a3;
	__m128i i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = _mm_loadu_si128((__m128i *)&s[i]);
		i32_a1 = _mm_loadu_si128((__m128i *)&s[i+4]);
		i32_a2 = _mm_loadu_si128((__m128i *)&s[i+8]);
		i32_a3 = _mm_loadu_si128((__m128i *)&s[i+12]);
		i32_b0 = _mm_loadu_si128((__m128i *)&d[i]);
		i32_b1 = _mm_loadu_si128((__m128i *)&d[i+4]);
		i32_b2 = _mm_loadu_si128((__m128i *)&d[i+8]);
		i32_b3 = _mm_loadu_si128((__m128i *)&d[i+12]);
		i32_a0 = _mm_add_epi32(i32_a0, i32_b0);
		i32_a1 = _mm_add_epi32(i32_a1, i32_b1);
		i32_a2 = _mm_add_epi32(i32_a2, i32_b2);
		i32_a3 = _mm_add_epi32(i32_a3, i32_b3);
		_mm_storeu_si128((__m128i*)&d[i], i32_a0);
		_mm_storeu_si128((__m128i*)&d[i+4], i32_a1);
		_mm_storeu_si128((__m128i*)&d[i+8], i32_a2);
		_mm_storeu_si128((__m128i*)&d[i+12], i32_a3);
	}
	}
#endif // USE_SSE
	for (; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}

	return iLen;
} /* simd_integer_sum() */

// Add the values from 2 arrays and store in the destination array
int c_float_sum(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* c_float_sum() */

// Add the values from 2 arrays and store in the destination array
int simd_float_sum(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	i = 0;
#ifdef USE_NEON
	{
	float32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	float32x4_t i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_f32(&s[i]);
		i32_a1 = vld1q_f32(&s[i+4]);
		i32_a2 = vld1q_f32(&s[i+8]);
		i32_a3 = vld1q_f32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_f32(&d[i]);
		i32_b1 = vld1q_f32(&d[i+4]);
		i32_b2 = vld1q_f32(&d[i+8]);
		i32_b3 = vld1q_f32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vaddq_f32(i32_a0, i32_b0);
		i32_a1 = vaddq_f32(i32_a1, i32_b1);
		i32_a2 = vaddq_f32(i32_a2, i32_b2);
		i32_a3 = vaddq_f32(i32_a3, i32_b3);
		vst1q_f32(&d[i], i32_a0);
		vst1q_f32(&d[i+4], i32_a1);
		vst1q_f32(&d[i+8], i32_a2);
		vst1q_f32(&d[i+12], i32_a3);
	}
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128 f32_a0, f32_a1, f32_a2, f32_a3;
	__m128 f32_b0, f32_b1, f32_b2, f32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		f32_a0 = _mm_loadu_ps(&s[i]);
		f32_a1 = _mm_loadu_ps(&s[i+4]);
		f32_a2 = _mm_loadu_ps(&s[i+8]);
		f32_a3 = _mm_loadu_ps(&s[i+12]);
		f32_b0 = _mm_loadu_ps(&d[i]);
		f32_b1 = _mm_loadu_ps(&d[i+4]);
		f32_b2 = _mm_loadu_ps(&d[i+8]);
		f32_b3 = _mm_loadu_ps(&d[i+12]);
		f32_a0 = _mm_add_ps(f32_a0, f32_b0);
		f32_a1 = _mm_add_ps(f32_a1, f32_b1);
		f32_a2 = _mm_add_ps(f32_a2, f32_b2);
		f32_a3 = _mm_add_ps(f32_a3, f32_b3);
		_mm_storeu_ps(&d[i], f32_a0);
		_mm_storeu_ps(&d[i+4], f32_a1);
		_mm_storeu_ps(&d[i+8], f32_a2);
		_mm_storeu_ps(&d[i+12], f32_a3);
	}
	}
#endif // USE_SSE

	for (; i<iLen; i++)
	{
		d[i] = d[i] + s[i];
	}
	return iLen;
} /* simd_float_sum() */

// Subtract the values from 2 arrays and store in the destination array
int c_integer_diff(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* c_integer_diff() */

// Subtract the values from 2 arrays and store in the destination array
int simd_integer_diff(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	i = 0;
#ifdef USE_NEON
	{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	int32x4_t i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_s32(&d[i]);
		i32_b1 = vld1q_s32(&d[i+4]);
		i32_b2 = vld1q_s32(&d[i+8]);
		i32_b3 = vld1q_s32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vsubq_s32(i32_a0, i32_b0);
		i32_a1 = vsubq_s32(i32_a1, i32_b1);
		i32_a2 = vsubq_s32(i32_a2, i32_b2);
		i32_a3 = vsubq_s32(i32_a3, i32_b3);
		vst1q_s32(&d[i], i32_a0);
		vst1q_s32(&d[i+4], i32_a1);
		vst1q_s32(&d[i+8], i32_a2);
		vst1q_s32(&d[i+12], i32_a3);
	}
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128i i32_a0, i32_a1, i32_a2, i32_a3;
	__m128i i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = _mm_loadu_si128((__m128i *)&s[i]);
		i32_a1 = _mm_loadu_si128((__m128i *)&s[i+4]);
		i32_a2 = _mm_loadu_si128((__m128i *)&s[i+8]);
		i32_a3 = _mm_loadu_si128((__m128i *)&s[i+12]);
		i32_b0 = _mm_loadu_si128((__m128i *)&d[i]);
		i32_b1 = _mm_loadu_si128((__m128i *)&d[i+4]);
		i32_b2 = _mm_loadu_si128((__m128i *)&d[i+8]);
		i32_b3 = _mm_loadu_si128((__m128i *)&d[i+12]);
		i32_a0 = _mm_sub_epi32(i32_a0, i32_b0);
		i32_a1 = _mm_sub_epi32(i32_a1, i32_b1);
		i32_a2 = _mm_sub_epi32(i32_a2, i32_b2);
		i32_a3 = _mm_sub_epi32(i32_a3, i32_b3);
		_mm_storeu_si128((__m128i*)&d[i], i32_a0);
		_mm_storeu_si128((__m128i*)&d[i+4], i32_a1);
		_mm_storeu_si128((__m128i*)&d[i+8], i32_a2);
		_mm_storeu_si128((__m128i*)&d[i+12], i32_a3);
	}
	}
#endif // USE_SSE

	for (; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* simd_integer_diff() */

// Subtract the values from 2 arrays and store in the destination array
int c_float_diff(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	for (i=0; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* c_float_diff() */

// Subtract the values from 2 arrays and store in the destination array
int simd_float_diff(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

	i = 0;

#ifdef USE_NEON
	{
	float32x4_t i32_a0, i32_a1, i32_a2, i32_a3;
	float32x4_t i32_b0, i32_b1, i32_b2, i32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_f32(&s[i]);
		i32_a1 = vld1q_f32(&s[i+4]);
		i32_a2 = vld1q_f32(&s[i+8]);
		i32_a3 = vld1q_f32(&s[i+12]);
	        __builtin_prefetch(&s[i+96]);
		i32_b0 = vld1q_f32(&d[i]);
		i32_b1 = vld1q_f32(&d[i+4]);
		i32_b2 = vld1q_f32(&d[i+8]);
		i32_b3 = vld1q_f32(&d[i+12]);
	        __builtin_prefetch(&d[i+96]);
		i32_a0 = vsubq_f32(i32_a0, i32_b0);
		i32_a1 = vsubq_f32(i32_a1, i32_b1);
		i32_a2 = vsubq_f32(i32_a2, i32_b2);
		i32_a3 = vsubq_f32(i32_a3, i32_b3);
		vst1q_f32(&d[i], i32_a0);
		vst1q_f32(&d[i+4], i32_a1);
		vst1q_f32(&d[i+8], i32_a2);
		vst1q_f32(&d[i+12], i32_a3);
	}
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128 f32_a0, f32_a1, f32_a2, f32_a3;
	__m128 f32_b0, f32_b1, f32_b2, f32_b3;

	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		f32_a0 = _mm_loadu_ps(&s[i]);
		f32_a1 = _mm_loadu_ps(&s[i+4]);
		f32_a2 = _mm_loadu_ps(&s[i+8]);
		f32_a3 = _mm_loadu_ps(&s[i+12]);
		f32_b0 = _mm_loadu_ps(&d[i]);
		f32_b1 = _mm_loadu_ps(&d[i+4]);
		f32_b2 = _mm_loadu_ps(&d[i+8]);
		f32_b3 = _mm_loadu_ps(&d[i+12]);
		f32_a0 = _mm_sub_ps(f32_a0, f32_b0);
		f32_a1 = _mm_sub_ps(f32_a1, f32_b1);
		f32_a2 = _mm_sub_ps(f32_a2, f32_b2);
		f32_a3 = _mm_sub_ps(f32_a3, f32_b3);
		_mm_storeu_ps(&d[i], f32_a0);
		_mm_storeu_ps(&d[i+4], f32_a1);
		_mm_storeu_ps(&d[i+8], f32_a2);
		_mm_storeu_ps(&d[i+12], f32_a3);
	}
	}
#endif // USE_SSE

	for (; i<iLen; i++)
	{
		d[i] = s[i] - d[i];
	}
	return iLen;
} /* simd_float_diff() */

// Find the maximum value in an array
int c_float_max(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;
float max;

	max = -10000;
	for (i=0; i<iLen; i++)
	{
		if (s[i] > max) max = s[i];
	}
	d[0] = max; // store the max value as element 0 in the output
	return 1;
} /* c_float_max() */

// Find the maximum value in an array
int simd_float_max(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;

#ifdef USE_NEON
	{
	float32x4_t xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	float32x4_t xmmMax0, xmmMax1, xmmMax2, xmmMax3;

        xmmMax0 = vld1q_f32(&s[0]);
        xmmMax1 = vld1q_f32(&s[4]);
        xmmMax2 = vld1q_f32(&s[8]);
        xmmMax3 = vld1q_f32(&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = vld1q_f32(&s[i]);
            xmmCur1 = vld1q_f32(&s[i+4]);
            xmmCur2 = vld1q_f32(&s[i+8]);
            xmmCur3 = vld1q_f32(&s[i+12]);
	    __builtin_prefetch(&s[i+96]);
            xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = vmaxq_f32(xmmCur1, xmmMax1);
	    xmmMax2 = vmaxq_f32(xmmCur2, xmmMax2);
	    xmmMax3 = vmaxq_f32(xmmCur3, xmmMax3);
        }
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax1);
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax2);
	xmmMax0 = vmaxq_f32(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = vextq_f32(xmmMax0, xmmMax0, 2); // compare upper and lower 2 values
        xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = vextq_f32(xmmMax0, xmmMax0, 1); // compare last 2 values
        xmmMax0 = vmaxq_f32(xmmCur0, xmmMax0); // keep max 1
        d[0] = vgetq_lane_f32(xmmMax0, 0);
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128 xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	__m128 xmmMax0, xmmMax1, xmmMax2, xmmMax3;
	float kludge[4];

        xmmMax0 = _mm_loadu_ps(&s[0]);
        xmmMax1 = _mm_loadu_ps(&s[4]);
        xmmMax2 = _mm_loadu_ps(&s[8]);
        xmmMax3 = _mm_loadu_ps(&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = _mm_loadu_ps(&s[i]);
            xmmCur1 = _mm_loadu_ps(&s[i+4]);
            xmmCur2 = _mm_loadu_ps(&s[i+8]);
            xmmCur3 = _mm_loadu_ps(&s[i+12]);
            xmmMax0 = _mm_max_ps(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = _mm_max_ps(xmmCur1, xmmMax1);
	    xmmMax2 = _mm_max_ps(xmmCur2, xmmMax2);
	    xmmMax3 = _mm_max_ps(xmmCur3, xmmMax3);
        }
	xmmMax0 = _mm_max_ps(xmmMax0, xmmMax1);
	xmmMax0 = _mm_max_ps(xmmMax0, xmmMax2);
	xmmMax0 = _mm_max_ps(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = (__m128)_mm_srli_si128((__m128i)xmmMax0, 8); // compare upper and lower 2 values
        xmmMax0 = _mm_max_ps(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = (__m128)_mm_srli_si128((__m128i)xmmMax0, 4); // compare last 2 values
        xmmMax0 = _mm_max_ps(xmmCur0, xmmMax0); // keep max 1
	_mm_storeu_ps(&kludge[0], xmmMax0); // no float extract in SSE/SSE2/SSE4
        d[0] = kludge[0];
	}
#endif // USE_SSE

	return 1;
} /* simd_float_max() */

// Find the maximum value in an array
int c_integer_max(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;
int32_t max;

	max = -10000;
	for (i=0; i<iLen; i++)
	{
		if (s[i] > max) max = s[i];
	}
	d[0] = max; // store the max value as element 0 in the output
	return 1;
} /* c_integer_max() */

// Find the maximum value in an array
int simd_integer_max(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

#ifdef USE_NEON
	{
	int32x4_t xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	int32x4_t xmmMax0, xmmMax1, xmmMax2, xmmMax3;

        xmmMax0 = vld1q_s32(&s[0]);
        xmmMax1 = vld1q_s32(&s[4]);
        xmmMax2 = vld1q_s32(&s[8]);
        xmmMax3 = vld1q_s32(&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = vld1q_s32(&s[i]);
            xmmCur1 = vld1q_s32(&s[i+4]);
            xmmCur2 = vld1q_s32(&s[i+8]);
            xmmCur3 = vld1q_s32(&s[i+12]);
            __builtin_prefetch(&s[i+96]);
            xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = vmaxq_s32(xmmCur1, xmmMax1);
	    xmmMax2 = vmaxq_s32(xmmCur2, xmmMax2);
	    xmmMax3 = vmaxq_s32(xmmCur3, xmmMax3);
        }
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax1);
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax2);
	xmmMax0 = vmaxq_s32(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = vextq_s32(xmmMax0, xmmMax0, 2); // compare upper and lower 2 values
        xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = vextq_s32(xmmMax0, xmmMax0, 1); // compare last 2 values
        xmmMax0 = vmaxq_s32(xmmCur0, xmmMax0); // keep max 1
        d[0] = vgetq_lane_s32(xmmMax0, 0);
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128i xmmCur0, xmmCur1, xmmCur2, xmmCur3;
	__m128i xmmMax0, xmmMax1, xmmMax2, xmmMax3;

        xmmMax0 = _mm_loadu_si128((__m128i *)&s[0]);
        xmmMax1 = _mm_loadu_si128((__m128i *)&s[4]);
        xmmMax2 = _mm_loadu_si128((__m128i *)&s[8]);
        xmmMax3 = _mm_loadu_si128((__m128i *)&s[12]);
        for (i=16; i< iLen-15; i+=16)
        {
            xmmCur0 = _mm_loadu_si128((__m128i *)&s[i]);
            xmmCur1 = _mm_loadu_si128((__m128i *)&s[i+4]);
            xmmCur2 = _mm_loadu_si128((__m128i *)&s[i+8]);
            xmmCur3 = _mm_loadu_si128((__m128i *)&s[i+12]);
            xmmMax0 = _mm_max_epi32(xmmCur0, xmmMax0); // hold on to the max 4 values
	    xmmMax1 = _mm_max_epi32(xmmCur1, xmmMax1);
	    xmmMax2 = _mm_max_epi32(xmmCur2, xmmMax2);
	    xmmMax3 = _mm_max_epi32(xmmCur3, xmmMax3);
        }
	xmmMax0 = _mm_max_epi32(xmmMax0, xmmMax1);
	xmmMax0 = _mm_max_epi32(xmmMax0, xmmMax2);
	xmmMax0 = _mm_max_epi32(xmmMax0, xmmMax3);
        // now we have the 4 max values, reduce to 1
        xmmCur0 = _mm_srli_si128(xmmMax0, 8); // compare upper and lower 2 values
        xmmMax0 = _mm_max_epi32(xmmCur0, xmmMax0); // keep max 2
        xmmCur0 = _mm_srli_si128(xmmMax0, 4); // compare last 2 values
        xmmMax0 = _mm_max_epi32(xmmCur0, xmmMax0); // keep max 1
        d[0] = _mm_cvtsi128_si32(xmmMax0);
	}
#endif // USE_SSE

	return 1;
} /* simd_integer_max() */

// Calculate the sum of all values in an array
int c_float_accumulate(void *in, void *out, int iLen)
{
int i;
float *s = (float *)in;
float *d = (float *)out;
float sum = 0.0;

	for (i=0; i<iLen; i++)
	{
		sum += s[i];
	}
	d[0] = sum;
	return 1;
} /* c_float_accumulate() */

// Calculate the sum of all values in an array
int simd_float_accumulate(void *in, void *out, int iLen)
{
int i;
float fSum;
float *s = (float *)in;
float *d = (float *)out;

	i = 0;
        fSum = 0.0;

#ifdef USE_NEON
	{
	float32x4_t f32_a0, f32_a1, f32_a2, f32_a3, f32_sum;
        float32x2_t f32_sum_narrow;

        f32_sum = vdupq_n_f32(0.0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		f32_a0 = vld1q_f32(&s[i]);
		f32_a1 = vld1q_f32(&s[i+4]);
		f32_a2 = vld1q_f32(&s[i+8]);
		f32_a3 = vld1q_f32(&s[i+12]);
		f32_a0 = vaddq_f32(f32_a0, f32_a1);
		f32_a1 = vaddq_f32(f32_a2, f32_a3);
                f32_sum = vaddq_f32(f32_sum, f32_a0);
                f32_sum = vaddq_f32(f32_sum, f32_a1);
	}
        f32_sum_narrow = vadd_f32(vget_high_f32(f32_sum), vget_low_f32(f32_sum));
        f32_sum_narrow = vpadd_f32(f32_sum_narrow, f32_sum_narrow);
        fSum = vget_lane_f32(f32_sum_narrow, 0);
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128 f32_a0, f32_a1, f32_a2, f32_a3, f32_sum;
	float kludge[4];

        f32_sum = _mm_set1_ps(0.0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		f32_a0 = _mm_loadu_ps(&s[i]);
		f32_a1 = _mm_loadu_ps(&s[i+4]);
		f32_a2 = _mm_loadu_ps(&s[i+8]);
		f32_a3 = _mm_loadu_ps(&s[i+12]);
		f32_a0 = _mm_add_ps(f32_a0, f32_a1);
		f32_a1 = _mm_add_ps(f32_a2, f32_a3);
                f32_sum = _mm_add_ps(f32_sum, f32_a0);
                f32_sum = _mm_add_ps(f32_sum, f32_a1);
	}
        f32_sum = _mm_add_ps(f32_sum, (__m128)_mm_srli_si128((__m128i)f32_sum, 8));
        f32_sum = _mm_add_ps(f32_sum, (__m128)_mm_srli_si128((__m128i)f32_sum, 4));
	_mm_storeu_ps(&kludge[0], f32_sum);
        fSum = kludge[0];
	}
#endif // USE_SSE

	for (; i<iLen; i++)
	{
		fSum += s[i];
	}
	d[0] = fSum;
	return 1;
} /* simd_float_accumulate() */

// Calculate the sum of all values in an array
int c_integer_accumulate(void *in, void *out, int iLen)
{
int i;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;
int sum = 0;

	for (i=0; i<iLen; i++)
	{
		sum += s[i];
	}
	d[0] = sum;
	return 1;
} /* c_integer_accumulate() */

// Calculate the sum of all values in an array
int simd_integer_accumulate(void *in, void *out, int iLen)
{
int i;
int32_t iSum;
int32_t *s = (int32_t *)in;
int32_t *d = (int32_t *)out;

	i = 0;
        iSum = 0;

#ifdef USE_NEON
	{
	int32x4_t i32_a0, i32_a1, i32_a2, i32_a3, i32_sum;
        int32x2_t i32_sum_narrow;

        i32_sum = vdupq_n_s32(0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = vld1q_s32(&s[i]);
		i32_a1 = vld1q_s32(&s[i+4]);
		i32_a2 = vld1q_s32(&s[i+8]);
		i32_a3 = vld1q_s32(&s[i+12]);
		i32_a0 = vaddq_s32(i32_a0, i32_a1);
		i32_a1 = vaddq_s32(i32_a2, i32_a3);
                i32_sum = vaddq_s32(i32_sum, i32_a0);
                i32_sum = vaddq_s32(i32_sum, i32_a1);
	}
        i32_sum_narrow = vadd_s32(vget_high_s32(i32_sum), vget_low_s32(i32_sum));
        i32_sum_narrow = vpadd_s32(i32_sum_narrow, i32_sum_narrow);
        iSum = vget_lane_s32(i32_sum_narrow, 0);
	}
#endif // USE_NEON
#ifdef USE_SSE
	{
	__m128i i32_a0, i32_a1, i32_a2, i32_a3, i32_sum;

        i32_sum = _mm_set1_epi32(0);
	for (; i<iLen-15; i+= 16) 	// do 16 at a time
	{
		i32_a0 = _mm_loadu_si128((__m128i*)&s[i]);
		i32_a1 = _mm_loadu_si128((__m128i*)&s[i+4]);
		i32_a2 = _mm_loadu_si128((__m128i*)&s[i+8]);
		i32_a3 = _mm_loadu_si128((__m128i*)&s[i+12]);
		i32_a0 = _mm_add_epi32(i32_a0, i32_a1);
		i32_a1 = _mm_add_epi32(i32_a2, i32_a3);
                i32_sum = _mm_add_epi32(i32_sum, i32_a0);
                i32_sum = _mm_add_epi32(i32_sum, i32_a1);
	}
        i32_sum = _mm_add_epi32(i32_sum, _mm_srli_si128(i32_sum, 8));
        i32_sum = _mm_add_epi32(i32_sum, _mm_srli_si128(i32_sum, 4));
        iSum = _mm_cvtsi128_si32(i32_sum);
	}
#endif // USE_SSE
	for (; i<iLen; i++)
	{
		iSum += s[i];
	}
	d[0] = iSum;
	return 1;
} /* simd_integer_accumulate() */
